#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <cmath>
#include <map>
#include <list>
using namespace std;
#define MAX_AVOID_FORCE 4

class Vector2D {
public:
    float x, y;
    
    Vector2D(float x = 0.0f, float y = 0.0f) : x(x), y(y) {}

    // Subtract two vectors
    Vector2D operator-(const Vector2D& v) const {
        return Vector2D(x - v.x, y - v.y);
    }
    
    // Calculate the length of the vector
    float Length() const {
        return std::sqrt(x * x + y * y);
    }
    
    // Normalize the vector
    Vector2D& Normalize() {
        float length = Length();
        if (length != 0) {
            x /= length;
            y /= length;
        }
        return *this;
    }

    // Scale the vector
    Vector2D operator*(float scalar) const {
        return Vector2D(x * scalar, y * scalar);
    }
};

// Method to calculate avoidance force
Vector2D CalculateAvoidanceForce(const Vector2D& ahead, const Vector2D& obstacle_center) {
    Vector2D avoidance_force = ahead - obstacle_center;
    avoidance_force.Normalize();
    avoidance_force = avoidance_force * MAX_AVOID_FORCE;
    return avoidance_force;
}
/**
 * Score points by scanning valuable fish faster than your opponent.
 **/

// calc distance 
    // prioritize 
         // if not scanned by opponent
         

         // if u have more entities different color
         // same color 

float   PI = 3.14;

float     calc_distance(int x, int y, int x_fish, int y_fish)
{
    //X1 = x_dst        X2= x_m + v_x_m
    //Y1 = y_dst        Y2= y_m + v_y_m

    return (sqrt(pow(((x - x_fish)), 2) + pow(((y - y_fish)), 2)));

}

class Entity
{
    public :
        int     id;
        int     color;
        int     type;
        int     x;
        int     y;
        int     vx;
        int     vy;
        int     scanned;
        string  pos;
        map<int, string> drone;
        map<int, string> dist;
        int     visible;
        Entity(int creature_id,int color,int type, int x_fish , int y_fish, int vx, int vy)
        {
            id = creature_id;
            this->color = color;
            this->type = type;
            x = x_fish;
            y = y_fish;
            scanned = 0;
            visible = 0;
            this->vx = vx;
            this->vy = vy;
        }
};      

class   drone
{
    public :
        int   drone_id;
        int     drone_x;
        int drone_y;
        int emergency;
        int battery;

        drone(int   id , int x , int y , int emergency , int battery)
        {
            drone_id = id;
            drone_x = x;
            drone_y = y;
            this->emergency = emergency;
            this->battery = battery;
        }
};

bool     compare(const Entity& v1, const Entity& v2)
{
    return (v1.type > v2.type);
}

int     j = -1;

vector<Entity> v;


int     scanned;
int     state = 0;;

// void    steering_from_monster(int x, int y, )
// {

// }

//move to report if a drone of my enemy reaches last 

list<int> radar_list;


void    set_coords(int &i, int id ,int& tmp_x, int& tmp_y,  map<int, pair<int, int>>& coords)
{
    // cerr << "type : " << v[j].type << endl;
    int     r = 0;

    //if my opennet does not scan a higher type of a fish 
     // and im scan it i have to report it before him
    
    
    //calc distance 
    //sqrt(x1 +)
    tmp_x = coords[id].first;
    tmp_y = coords[id].second;
    // cerr << "scanned : " << scanned_count << endl;
    if (find(radar_list.begin(), radar_list.end(), v[i].id) == radar_list.end())
    {
        v.erase(v.begin());
    }
    if (v.empty())
    {
        tmp_x = 600;
        tmp_y = 0;
        return ;
    }
    // cerr << "s : " << s << " coords : " << tmp_x << " " << tmp_y << endl; 
    if (v[i].drone[id] == "TL" || v[i].drone[id] == "BL")
    {
        tmp_x -= 600; 
    }
    else if (v[i].drone[id] == "TR" || v[i].drone[id] == "BR")
    {
        tmp_x += 600; 
    }
    if (v[i].drone[id][0] == 'B')
        tmp_y += 600;
    else
        tmp_y -= 600;
    
    if (tmp_x < 0 || tmp_x > 9999)
    {
        tmp_x = 600;
    }
    if (tmp_y < 0 || tmp_y > 9999)
    {
        tmp_y = 600;
    }
    if (tmp_x == 600)
    {
        cerr << "skipped boundries , id : " << v[i].id << endl;
        // v[i].scanned = 1;
    }

    //calculate the distance between next point of player and monster
        //if its within the radius
            //calculate other position distance 
            //if find a valid way move to it
        //else
            //move normally


    float radian;
    float degree;
    double     x;
    double     y;
    int     dist;

   
    // r = 0;
    // x = tmp_x;
    // y = tmp_y;
    // while (r < v.size())
    // {
    //     if (v[r].type == -1 && v[r].x)
    //     {
    //         int n = r;
    //         while (r < v.size())
    //         {
    //             // cerr << "Entred" << endl;
    //             dist = calc_distance(x, y, v[r].x + v[r].vx, v[r].vy + v[r].y);
    //             if (dist <= 900)
    //             {
    //                 // cerr << "here" << endl;
    //                  cerr << "player id : " << id << " monster id : " << v[r].id <<  " x monster : " << v[r].x 
    //                     << " y monster : " << v[r].y << endl;
    //                 x = x - v[r].vx;
    //                 y = y - v[r].vy;
    //                 int length = std::sqrt(x * x + y * y);
    //                 if (length)
    //                 {
    //                     x /= length;
    //                     y /= length;
    //                 }
    //                 x *= MAX_AVOID_FORCE;
    //                 y *= MAX_AVOID_FORCE;
    //             }
    //             r++;
    //         }
    //         if (dist <= 900)
    //         {
    //             tmp_x = x;
    //             tmp_y = y;
    //             return ;
    //         }
    //     }
    //     r++;
    // }
    
    
    x = coords[id].first;
    y = coords[id].second + 600;
    degree = 20;
    // cerr << "player coordinates : " << coords[id].first << " "
    // << coords[id].second << endl;
    // radian = degree * (PI / 180);
    // cerr << "Before : " << endl;
    // cerr << "x : " << x << endl;
    // cerr << "y : " << tmp_y << endl;

    // x -= coords[id].first;
    // y -= coords[id].second; 
    // x =  x * cos(radian) - (y  * -sin(radian));
    // y =  x * -sin(radian) + (y   * cos(radian));
    // x += coords[id].first;
    // y += coords[id].second;
    // cerr << "After : " << endl;
    // cerr << "x : " << x << endl;
    // cerr << "y : " << y << endl;
    // dist = calc_distance(x, y, v[r].x + v[r].vx, v[r].vy + v[r].y);
    while (r < v.size())
    {
        if (v[r].type == -1 && v[r].x)
        {
            int n = r;
            while (r < v.size() && degree < 360)
            {
                if (v[r].x)
                {
                    
                    // dist = calc_distance(x, y, v[r].x + v[r].vx, v[r].vy + v[r].y);
                    // if (dist <= 900)
                    // {
                        //Vector rotate(float angle, Vector rotation_center)
                //         {
                //             *this -= rotation_center;
                //             double _cos = cos(angle * M_PI / 180); 
                //             double _sin = -sin(angle * M_PI / 180);
                //             Vector rotater(x * _cos - y * _sin , x * _sin + y * _cos);
                //             return (rotater + rotation_center);
                //         }
                        // cerr << "degree : " << degree << endl; 
                        cerr << "player id : " << id << " monster id : " << v[r].id <<  " x monster : " << v[r].x 
                             << " y monster : " << v[r].y << endl;
                        cerr << "player coordinates : " << coords[id].first << " " << coords[id].second << endl;
                       
                        cerr << "Before : " << endl;
                        cerr << "x : " << x << endl;
                        cerr << "y : " << y << endl;

                        x -= coords[id].first;
                        y -= coords[id].second; 
                        
                        double _cos = cos(30 * M_PI / 180);
                        double _sin = -sin(30 * M_PI / 180);
                        x =  x * _cos - (y  * _sin);
                        y =  x * _sin + (y * _cos);
                        x += coords[id].first;
                        y += coords[id].second;
                        cerr << "After : " << endl;
                        cerr << "x : " << x << endl;
                        cerr << "y : " << y << endl;
                        exit(0);
                        dist = calc_distance(x, y, v[r].x + v[r].vx, v[r].vy + v[r].y);
                        
                        
                        if (dist <= 600)
                        {
                            
                            degree += 40;
                            
                            r = n;
                         

                            // break ;
                            continue ;
                        } 
                    // }
                }
                r++;
            }
            if (degree > 40)
            {
                tmp_x = x;
                tmp_y = y;
                return ;
            }
        }
        r++;
    }
    //         if (degree > 20)
    //         {
    //             cerr << "degree : " << degree << endl;
    //             cerr << "id : " << id << endl;
    //             tmp_x = x;
    //             tmp_y = y;
    //             cerr << "next point (" << tmp_x << ", " << tmp_y << ")"<< endl;
    //             return ;
    //         }
    //         break ;
    //     }
    //     r++;
    // }

    // r = 0;
    // while (r < v.size())
    // {
    //     if (v[r].type == -1 && v[r].x)
    //     {
    //         while (r < v.size())
    //         {
    //             int dist;
    //             dist = calc_distance(tmp_x, tmp_y, v[r].x + v[r].vx, v[r].vy + v[r].y);
    //             // cerr << "dist between " << "drone : " << id << " and monster " << v[r].id << "=> " << dist << endl;
    //             if (dist <= 900)
    //             {
    //                 // cerr << "detected" << endl;
    //                 // cerr << "direction : " <<  v[i].drone[id] << endl;
    //                 // cerr << "vv : " << v[r].vy << endl;
    //                 if (v[r].vx > 0 && v[i].drone[id][1] == 'L')
    //                 {
    //                     tmp_x += 400;
    //                 }
    //                 else if (v[r].vx < 0 && v[i].drone[id][1] == 'R')
    //                 {
    //                     // cerr << "here" << endl;
    //                     tmp_x -= 1000;
    //                 }
                   
    //                 if (v[r].vy >= 0) //&&  v[i].drone[id][0] == 'B')
    //                 {
    //                     // cerr << "bottom" << endl;
    //                     tmp_y += 400;
    //                 }
    //                 else if (v[r].vy < 0 &&  v[i].drone[id][0] == 'T')
    //                 {
    //                     // cerr << "enter" << endl;
    //                     tmp_y -= 600;
    //                 }
    //             }
                
                
    //             // cerr << "finding a monster" << endl;
                
    //             r++;
    //         }
            
    //     }
    //     r++;
    // }
 
    // cerr << "i : " << i << " , id1 : " << v[i].id << endl;
    // cerr << "pos : " << v[i].drone[i] << endl;
    // cerr << "id : " << v[j].id << " pos : " << v[j].drone[i]
    //      << " , depend on : " << v[j].id <<  endl;
}


// (abs(tmp_x - v[r].x) <= 300 || abs(tm p_y - v[r].y) <= 300))
                // cerr << "monster x : " << v[r].x << " monster y : " << v[r].y << endl;
                // int dist;
                // dist = calc_distance(tmp_x, tmp_y, v[r].x + v[r].vx, v[r].vy + v[r].y);
                // cerr << "dist between " << "drone : " << id << " and monster " << v[r].id << "=> " << dist << endl;
                // if (dist <= 900)
                // {
                //     cerr << "detected" << endl;
                //     cerr << "direction : " <<  v[i].drone[id] << endl;
                //     cerr << "vv : " << v[r].vy << endl;
                //     if (v[r].vx > 0 && v[i].drone[id][1] == 'L')
                //     {
                //         tmp_x += 400;
                //     }
                //     else if (v[r].vx < 0 && v[i].drone[id][1] == 'R')
                //     {
                //         cerr << "here" << endl;
                //         tmp_x -= 1000;
                //     }
                   
                //     if (v[r].vy >= 0) //&&  v[i].drone[id][0] == 'B')
                //     {
                //         cerr << "bottom" << endl;
                //         tmp_y += 400;
                //     }
                //     else if (v[r].vy < 0 &&  v[i].drone[id][0] == 'T')
                //     {
                //         cerr << "enter" << endl;
                //         tmp_y -= 600;
                //     }
                // }
                
                
                // // cerr << "finding a monster" << endl;
                
                // r++;








// int     st = 0;
// int     arr[2] = {1, 1};
// list<int> radar_list;

// void    set_coords(int &i, int id ,int& tmp_x, int& tmp_y,  map<int, pair<int, int>>& coords)
// {
//     // cerr << "type : " << v[j].type << endl;
//     int     r = 0;

    
//     if (find(radar_list.begin(), radar_list.end(), v[i].id) == radar_list.end())
//     {
//         v.erase(v.begin());
//     }
//     //calc distance 
//     //sqrt(x1 +)
//     tmp_x = coords[id].first;
//     tmp_y = coords[id].second;
//     // cerr << "scanned : " << scanned_count << endl;
    
//     if (v.empty())
//     {
//         tmp_x = 400;
//         tmp_y = 0;
//         return ;
//     }
//     // cerr << "s : " << s << " coords : " << tmp_x << " " << tmp_y << endl; 
//     if (v[i].drone[id] == "TL" || v[i].drone[id] == "BL")
//     {
//         tmp_x -= 400; 
//     }
//     else if (v[i].drone[id] == "TR" || v[i].drone[id] == "BR")
//     {
//         tmp_x += 400; 
//     }
//     if (v[i].drone[id][0] == 'B')
//         tmp_y += 400;
//     else
//         tmp_y -= 400;
    
//     if (tmp_x < 0 || tmp_x > 9999)
//     {
//         tmp_x = 500;
//     }
//     if (tmp_y < 0 || tmp_y > 9999)
//     {
//         tmp_y = 500;
//     }
//     if (tmp_x == 500)
//     {
//         cerr << "skipped boundries , id : " << v[i].id << endl;
//         // v[i].scanned = 1;
//     }

//     //calculate the distance between next point of player and monster
//         //if its within the radius
//             //calculate other position distance 
//             //if find a valid way move to it
//         //else
//             //move normally

//     while (r < v.size())
//     {
//         if (v[r].type == -1 && v[r].x)
//         {
//             while (r < v.size())
//             {
//                 // (abs(tmp_x - v[r].x) <= 300 || abs(tmp_y - v[r].y) <= 300))
//                 // cerr << "monster x : " << v[r].x << " monster y : " << v[r].y << endl;
//                 int dist;

//                 dist = calc_distance(tmp_x, tmp_y, v[r].x + v[r].vx, v[r].vy + v[r].y);
//                 cerr << "dist between " << "drone : " << id << " and monster " << v[r].id << "=> " << dist << endl;
//                 if (dist <= 800)
//                 {
//                     cerr << "detected" << endl;
//                     cerr << "direction : " <<  v[i].drone[id] << endl;
//                     cerr << "vy : " << v[r].vy << endl;
//                     st = 1;
//                     if (arr[0] == 1)
//                         arr[0] = id;
//                     else if (arr[0] != id)
//                         arr[1] = id;
//                     if (v[r].vx > 0)
//                     {
//                         cerr << "here" << endl;
//                         tmp_x = coords[id].first + 400;
//                     }
//                     else if (v[r].vx < 0)
//                     {
//                         cerr << "here" << endl;
//                         tmp_x = coords[id].first - 400;
//                     }
                    
//                     tmp_x = coords[id].first;
//                     break ;
//                 }
                
                
//                 // cerr << "finding a monster" << endl;
                
//                 r++;
//             }
//             // tmp_x = coords[id].first;
            
//         }
        
//         r++;
        
//     }
//     if (st && (arr[0] == id || arr[1] == id))
//     {
//         // tmp_x = coords[id].first;
//         tmp_y = 0;
//     }
//     if (!coords[id].second)
//     {   
//         st = 0;
//         v[r].x = 0;                                                                                                                                                                                                                   
//         v[r].y = 0;
//         if (arr[0] == id)
//             arr[0] = 1;
//         else if (arr[1] == id)
//             arr[1] = 1;
//     }
//     // cerr << "i : " << i << " , id1 : " << v[i].id << endl;
//     // cerr << "pos : " << v[i].drone[i] << endl;
//     // cerr << "id : " << v[j].id << " pos : " << v[j].drone[i]
//     //      << " , depend on : " << v[j].id <<  endl;
// }

int main()
{
    int creature_count;
    cin >> creature_count; cin.ignore();
    vector<int> scan_id;
    vector<Entity> creatures;
    vector<drone> drones;
    int     j;

    for (int i = 0; i < creature_count; i++) {
        int creature_id;
        int color;
        int type;
      
        cin >> creature_id >> color >> type; cin.ignore();
        v.push_back(Entity(creature_id , color , type, 0 , 0, 0, 0));
    }
    int state = 0;
    int     ids[2];
    // game loop
    // vector<int> scanned;
    while (1) {
    
        map<int, pair<int, int>> coords;

        int my_score;
        cin >> my_score; cin.ignore();
        int foe_score;
        cin >> foe_score; cin.ignore();
        int my_scan_count;
        cin >> my_scan_count; cin.ignore();

        for (int i = 0; i < my_scan_count; i++) {
            int creature_id;
            cin >> creature_id; cin.ignore();
        }
        
        
        int foe_scan_count;
        cin >> foe_scan_count; cin.ignore();
        for (int i = 0; i < foe_scan_count; i++) {
            int creature_id;
            cin >> creature_id; cin.ignore();
        }
        int my_drone_count;
        cin >> my_drone_count; cin.ignore();
        int drone_id;
        int drone_x;
        int drone_y;
        int emergency;
        int battery;
        

        for (int i = 0; i < my_drone_count; i++) {
            cin >> drone_id >> drone_x >> drone_y >> emergency >> battery; cin.ignore();
            ids[i] = drone_id;
            drones.push_back(drone(drone_id , drone_x , drone_y , emergency , battery));
            // cerr << "id : " << ids[i] << endl;
            coords[drone_id] = make_pair(drone_x, drone_y);
        }
        int foe_drone_count;
        cin >> foe_drone_count; cin.ignore();
       

        for (int i = 0; i < foe_drone_count; i++) {
            int drone_id;
            int drone_x;
            int drone_y;
            int emergency;
            int battery;
            cin >> drone_id >> drone_x >> drone_y >> emergency >> battery; cin.ignore();
        }
        int drone_scan_count;
        cin >> drone_scan_count; cin.ignore();
        
        for (int i = 0; i < drone_scan_count; i++) {
            int drone_id;
            int creature_id;
            cin >> drone_id >> creature_id; cin.ignore();
            j = -1;
            while (++j < v.size() && (drone_id == ids[0] || drone_id == ids[1]))
            {
                // if (v[j].type == -1)
                //     cerr << "is a monster" << endl;
                if (v[j].id == creature_id)
                {
                    v[j].scanned = 1;
                    break ; 
                }
            }
            // cerr << "scanned id : " << creature_id << endl;
            // if (drone_id == ids[0] || drone_id == ids[1])
            // {
            //     if (find(scanned.begin(), scanned.end(), creature_id) == scanned.end())
            //         scanned.push_back(creature_id);
            // }
        }
        int visible_creature_count;
        cin >> visible_creature_count; cin.ignore();
        
        for (int i = 0; i < visible_creature_count; i++) {
            int creature_id;
            int creature_x;
            int creature_y;
            int creature_vx;
            int creature_vy;
            cin >> creature_id >> creature_x >> creature_y >> creature_vx >> creature_vy; cin.ignore();
            j = -1;
            while (++j < v.size())
            {
                //u have to reset value of monsters not detected by radar
                if (v[j].id == creature_id)
                {
                    v[j].dist[ids[0]] = calc_distance(coords[ids[0]].first, coords[ids[0]].second, creature_x, creature_y);
                    v[j].dist[ids[1]] = calc_distance(coords[ids[1]].first, coords[ids[1]].second, creature_x, creature_y);
                    v[j].x = creature_x;
                    v[j].y = creature_y;
                    v[j].vx = creature_vx;
                    v[j].vy = creature_vy;
                    break ;
                }
            }
            
        }
        int radar_blip_count;
        cin >> radar_blip_count; cin.ignore();
        radar_list.clear();
        //ki3tik creature_id li ba9in 
        for (int i = 0; i < radar_blip_count; i++) {
            int drone_id;
            int creature_id;
            if (i < radar_blip_count / 2)
                radar_list.push_back(creature_id);
            // cerr << "radar id : " << creature_id << endl;
            string radar;
            cin >> drone_id >> creature_id >> radar; cin.ignore();
            int j = -1;
            while (++j < creature_count)
            {
                if (v[j].id == creature_id)
                { 
                    //check type of monster
                    v[j].drone[drone_id] = radar;
                    
                    // cerr << "fish id : " << creature_id << endl;
                    // cerr << "pos : " << radar << endl;
                    break ;
                }
            }
            // cerr << "radar : " << radar << endl;
            // cerr << "drone id : " << drone_id << endl;

        }
       
        int s = 0;
        
        sort(v.begin(), v.end(), compare);
        // j = -1;
        // while (++j < creature_count)
        // {
        //    cerr << "type : " << v[j].type << endl;
        // }
        int     tmp_x;
        int     tmp_y;
      
        // aya wahda nscanniha nb9a tab3ha 7ta n5rjha mn borders
        // if (scanned.size() == 11)
        //     cerr << "size : " << scanned.back() << endl;
        j = -1;
        while (++j < v.size())
        {
            if (v[j].scanned)
            {
                if (v[j].type == -1)
                {
                    cerr << "\t here \t\n";
                }
                v.erase(v.begin() + j);
            }
        }

        for (int i = 0; i < my_drone_count; i++) {

            // Write an action using cout. DON'T FORGET THE "<< endl"
            // // To debug: cerr << "Debug messages..." << endl;
            set_coords(i, ids[i], tmp_x, tmp_y, coords);
            if (v.empty())
            {
                cerr << "move to report" << endl;
                cout << "MOVE " << 500 << " " << 0 << " 0" << endl;
            }
            else
            {
                
                if (tmp_y - 500 >= 1500 && battery >= 5 && tmp_y)
                {
                    cout << "MOVE " << tmp_x << " " << tmp_y << " 0" << endl; // MOVE <x> <y> <light (1|0)> | WAIT <light (1|0)>
                }
                else
                {
                    cout << "MOVE " << tmp_x << " " << tmp_y << " 0" << endl; // MOVE <x> <y> <light (1|0)> | WAIT <light (1|0)>
                }

            }

        }
    }
}
