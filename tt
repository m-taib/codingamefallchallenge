#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <cmath>
#include <map>
#include <list>
using namespace std;
#define MAX_AVOID_FORCE 4
#define target_up   0
#define target_down 9000


float     calc_distance(int x, int y, int x_fish, int y_fish)
{
    //X1 = x_dst        X2= x_m + v_x_m
    //Y1 = y_dst        Y2= y_m + v_y_m

    return (sqrt(pow(((x - x_fish)), 2) + pow(((y - y_fish)), 2)));

}

class Entity
{
    public :
        int     id;
        int     color;
        int     type;
        int     x;
        int     y;
        int     vx;
        int     vy;
        int     scanned;
        string  pos;
        map<int, string> drone;
        map<int, string> dist;
        int     visible;
        Entity(int creature_id,int color,int type, int x_fish , int y_fish, int vx, int vy)
        {
            id = creature_id;
            this->color = color;
            this->type = type;
            x = x_fish;
            y = y_fish;
            scanned = 0;
            visible = 0;
            this->vx = vx;
            this->vy = vy;
        }
};      

class   Monster
{
    public :
        int     id;
        int     x;
        int     y;
        int     vx;
        int     vy;
        Monster(int id,  int x, int y, int vx, int vy)
        {
            this->id = id;
            this->x =  x;
            this->y  = y;
            this->vx  = vx;
            this->vy = vy;
        };

};

class   Drone
{
    public :
        int   id;
        int     x;
        int     y;
        int     vx;
        int     vy;
        int emergency;
        int battery;

        Drone(int id , int x , int y , int vx, int vy, int emergency , int battery)
        {
            this->id = id;
            this->x = x;
            this->y = y;
            this->emergency = emergency;
            this->battery = battery;
        }
};

bool     compare(const Entity& v1, const Entity& v2)
{
    return (v1.type > v2.type);
}

int     j = -1;

vector<Entity> v;


int     scanned;
int     state = 0;

// void    steering_from_monster(int x, int y, )
// {

// }

//move to report if a drone of my enemy reaches last 

list<int> radar_list;
vector<int> top;
vector<int>::iterator it;

int     arr[2] = {0, 0};

// i have to turn off light if im close to monster
int     lamba[2] = {0, 0};
int     check_borders(int &tmp_y)
{
    if (tmp_y < 9999)
        return (1);
    return (0);
}
int     light[2] = {0, 0};

void    make_decision(int &i, int id ,int& tmp_x, int& tmp_y,  map<int, pair<int, int>>& coords)
{
    float x;
    float y;
    int     dist_from_monster_next_point = 0;
    int     dist_from_monster = 0;
    int     angle = 0;
    int     min = 0;
    int     r = v.size() - 1;
   

    r = v.size() - 1;
    
    while (r >= 0 && v[r].type == -1) 
    {
        r--;
    }
    r++;
    cerr << "r : " << r << endl;
   
    int     dist;
    int     state;

    map<int, pair<int, int> > next_points;

    dist = 0;
    min = 9000;
    int n = r;
    x = tmp_x;
    y = tmp_y;
    cerr << "player coordinates : " << x << " " << y - 600 << endl;
    cerr << "next point : " << x << " " << y << endl;
    if (r > 0 && v[r].type == -1)
    {
        while (angle <= 360)
        {
            
            state = 0;
            r = n;
            while (r < v.size())
            {
                if (v[r].x)
                {
                    x -= coords[id].first;
                    y -= coords[id].second; 
                    
                    double _cos = cos(angle * M_PI / 180);
                    double _sin = -sin(angle * M_PI / 180);
            
                    double x_new = x * _cos - y * _sin; 
                    double y_new = x * _sin + y * _cos; 

                    x = x_new + coords[id].first;
                    y = y_new + coords[id].second;

                    dist_from_monster = calc_distance(x, y, v[r].x , v[r].y);
                    dist_from_monster_next_point = calc_distance(x, y, v[r].x + v[r].vx, v[r].y + v[r].vy);
                    
                    int     d = light[i] ? 800 : 800;
                    // if (id == 2)
                    // {
                    // cerr << "player id : " << id << " monster id : " << v[r].id <<  " x monster : " << v[r].x 
                    //         << " y monster : " << v[r].y << endl;
                    // cerr << "radius : " << d << endl;
                    // }
                    //check borders
                    if (/*check_borders(y) && */(dist_from_monster <= d || dist_from_monster_next_point <= d))
                    {
                        lamba[i] = 1;
                        // cerr << "player id : " << id << " monster id : " << v[r].id <<  " x monster : " << v[r].x 
                        //     << " y monster : " << v[r].y << endl;
                        // cerr << "player coordinates : " << coords[id].first << " " << coords[id].second << endl;
                        // cerr << "distance from monster : " << dist_from_monster << endl;
                        // cerr << "distance from next point monster : " << dist_from_monster_next_point << endl;
                        state = 1;
                        break ;
                        // cerr << "Before : " << endl;
                        // cerr << "x : " << x << endl;
                        // cerr << "y : " << y << endl;
                    
                       
                        // cerr << "After : " << endl;
                        // cerr << "x : " << x << endl;
                        // cerr << "y : " << y << endl;    
                        
                    }
                    
                    // dist = calc_distance(tmp_x, tmp_y, x , y);
                    // next_point[dist] = make_pair(x, y);
                }
                r++;
            }
            if (state)
            {
                // cerr << "not valid" << endl;
                angle += 20;
                continue ;
            }
            else
            {
                // cerr << "valid" << endl;
                // cerr << "x : " << tmp_x << " y : " << tmp_y << endl;
                dist = calc_distance(tmp_x, tmp_y, x , y);
                next_points[dist] = make_pair(x, y);

            }
            angle += 20;        
        }
        // if (angle)
        // {
        //     // next_points[dist_from_monster_next_point] = make_pair(x, y);
        //     tmp_x = x;
        //     tmp_y = y;
        //     cerr << "Entred " << endl;
        // }
    }
    cerr << "size : " << next_points.size() << endl;
    if (next_points.size())
    {
        tmp_x = next_points.begin()->second.first;
        tmp_y = next_points.begin()->second.second;
        // cerr << "closet point : " << endl;
        // cerr << "x : " << tmp_x << " y : " << tmp_y << endl;

    }
       
}

int     check_territory(int x, int y,  vector<Monster>& visible_monster)
{
    int     i;
    int     dist_from_monster;
    int     dist_from_monster_next_point;

    i = 0;
    while (i < visible_monster.size())
    {
        dist_from_monster = calc_distance(x, y, visible_monster[i].x , visible_monster[i].y);
        dist_from_monster_next_point = calc_distance(x, y, visible_monster[i].x + visible_monster[i].vx, visible_monster[i].y + visible_monster[i].vy);
        if (dist_from_monster <= 800 || dist_from_monster_next_point <= 800)
            return (1);
        i++;
    }
    return (0);
}

void    set_coords(Drone& drone,  vector<Monster>& visible_monster)
{
    int     dist_from_monster_next_point = 0;
    int     dist_from_monster = 0;
    int     angle = 0;
    map<int, pair<int, int> > next_points;


    //add velocity to drone
    if (drone.y + 600 > target_down)
    {
        drone.vy = target_down;
    }
    else if (drone.y - 600 > target_up)
    {

    }
    if (drone.y < target_down)
    {
        drone.vy += 600;
    }
    else if ()
    if (visible_monster.size())
    {
        int     x;
        int     y;
        
        x  = drone.x;
        y  = drone.y;
        x -= drone.x;
        y -= drone.y; 
        
        double _cos = cos(angle * M_PI / 180);
        double _sin = -sin(angle * M_PI / 180);

        double x_new = x * _cos - y * _sin; 
        double y_new = x * _sin + y * _cos; 

        x = x_new + drone.x;
        y = y_new + drone.y;

        while (angle <= 360)
        {
            if (check_territory(x, y, visible_monster))
            {
                angle += 20;
                continue ;
            }
            else
            {

            }
            angle += 20;
        }
        return ;
    }
















    // if (find(radar_list.begin(), radar_list.end(), v[i].id) == radar_list.end())
    // {
    //     v.erase(v.begin());
    // }
    // tmp_x = coords[id].first;
    // tmp_y = coords[id].second;
    // if (top.size())
    // {
    //     it = find(top.begin(), top.end(), id);
    //     if (it != top.end())
    //     {
    //         if (coords[id].second)
    //         {
    //             tmp_y -= 600;
    //             if (tmp_y < 0)
    //                 tmp_y = 0;
    //             make_decision( i,  id ,tmp_x, tmp_y, coords);
    //             cerr << "wahya" << endl;
    //             return ;
    //         }
    //         top.erase(it);
    //     }
    //     // cerr << "id : " << id << endl;
    // }
    // if (tmp_y < 8900)
    // {
    //     // cerr << "plus y " << endl;
    //     // cerr << "id : " << id << endl;
    //     tmp_y += 600;
    //     // cerr << "y : " << tmp_y << endl;
    //     if (tmp_y > 8900)
    //         tmp_y = 8900;
    // }
    // else
    // {
    //     if (find(top.begin(), top.end(), id) == top.end())
    //         top.push_back(id);
    //     tmp_y -= coords[id].second - 600;
    //     return ;
    // }
    // if (tmp_y >= 8900)
    // {
    //     if (find(top.begin(), top.end(), id) == top.end())
    //         top.push_back(id);
    //     tmp_y -= 600;
    //     // return ;
    // }
     
    // make_decision( i,  id ,tmp_x, tmp_y, coords);

   
}

int main()
{
    int creature_count;
    cin >> creature_count; cin.ignore();
    vector<int> scan_id;
    vector<Monster> monsters;

    int     j;

    for (int i = 0; i < creature_count; i++) {
        int creature_id;
        int color;
        int type;
      
        cin >> creature_id >> color >> type; cin.ignore();
        if (type == -1)
            monsters.push_back(Monster(creature_id, 0, 0, 0, 0));
        else
            v.push_back(Entity(creature_id , color , type, 0 , 0, 0, 0));
    }
    int state = 0;
    int     ids[2];
    // game loop
    // vector<int> scanned;
    int     turn = -1; 
    while (1) {
        turn++; 
        vector<Monster> visible_monsters;

        map<int, pair<int, int>> coords;
        vector<Drone> drone;

        int my_score;
        cin >> my_score; cin.ignore();
        int foe_score;
        cin >> foe_score; cin.ignore();
        int my_scan_count;
        cin >> my_scan_count; cin.ignore();

        for (int i = 0; i < my_scan_count; i++) {
            int creature_id;
            cin >> creature_id; cin.ignore();
        }
        
        
        int foe_scan_count;
        cin >> foe_scan_count; cin.ignore();
        for (int i = 0; i < foe_scan_count; i++) {
            int creature_id;
            cin >> creature_id; cin.ignore();
        }
        int my_drone_count;
        cin >> my_drone_count; cin.ignore();
        int drone_id;
        int drone_x;
        int drone_y;
        int emergency;
        int battery;
        

        for (int i = 0; i < my_drone_count; i++) {
            cin >> drone_id >> drone_x >> drone_y >> emergency >> battery; cin.ignore();
            ids[i] = drone_id;
            drones.push_back(Drone(drone_id , drone_x , drone_y ,  drone_x , drone_y, emergency , battery));
            // cerr << "id : " << ids[i] << endl;
            coords[drone_id] = make_pair(drone_x, drone_y);
        }
        int foe_drone_count;
        cin >> foe_drone_count; cin.ignore();
       

        for (int i = 0; i < foe_drone_count; i++) {
            int drone_id;
            int drone_x;
            int drone_y;
            int emergency;
            int battery;
            cin >> drone_id >> drone_x >> drone_y >> emergency >> battery; cin.ignore();
        }
        int drone_scan_count;
        cin >> drone_scan_count; cin.ignore();
        
        for (int i = 0; i < drone_scan_count; i++) {
            int drone_id;
            int creature_id;
            cin >> drone_id >> creature_id; cin.ignore();
            j = -1;
            while (++j < v.size() && (drone_id == ids[0] || drone_id == ids[1]))
            {
                // if (v[j].type == -1)
                //     cerr << "is a monster" << endl;
                if (v[j].id == creature_id)
                {
                    v[j].scanned = 1;
                    break ; 
                }
            }
            // cerr << "scanned id : " << creature_id << endl;
            // if (drone_id == ids[0] || drone_id == ids[1])
            // {
            //     if (find(scanned.begin(), scanned.end(), creature_id) == scanned.end())
            //         scanned.push_back(creature_id);
            // }
        }
        int visible_creature_count;
        cin >> visible_creature_count; cin.ignore();
        
        // j = -1;
        // while (++j < v.size())
        // {
        //     v[j].x = 0;
        //     v[j].y = 0;
        //     v[j].vx = 0;
        //     v[j].vy = 0;
        // }
        for (int i = 0; i < visible_creature_count; i++) {
            int creature_id;
            int creature_x;
            int creature_y;
            int creature_vx;
            int creature_vy;
            cin >> creature_id >> creature_x >> creature_y >> creature_vx >> creature_vy; cin.ignore();

            j = -1;
            while (++j < monsters.size())
            {
                if (monsters[j].id == creature_id)
                {
                    visible_monsters.push_back(Monster(creature_id, creature_x, creature_y, creature_vx, creature_vy));
                    break ;
                }
            }
            j = -1;
            while (++j < v.size())
            {
                //u have to reset value of monsters not detected by radar
                if (v[j].id == creature_id)
                {
                    v[j].dist[ids[0]] = calc_distance(coords[ids[0]].first, coords[ids[0]].second, creature_x, creature_y);
                    v[j].dist[ids[1]] = calc_distance(coords[ids[1]].first, coords[ids[1]].second, creature_x, creature_y);
                    v[j].x = creature_x;
                    v[j].y = creature_y;
                    v[j].vx = creature_vx;
                    v[j].vy = creature_vy;
                    break ;
                }
            }
            
        }
        int radar_blip_count;
        cin >> radar_blip_count; cin.ignore();
        radar_list.clear();
        //ki3tik creature_id li ba9in 
        for (int i = 0; i < radar_blip_count; i++) {
            int drone_id;
            int creature_id;
            if (i < radar_blip_count / 2)
                radar_list.push_back(creature_id);
            // cerr << "radar id : " << creature_id << endl;
            string radar;
            cin >> drone_id >> creature_id >> radar; cin.ignore();
            int j = -1;
            while (++j < creature_count)
            {
                if (v[j].id == creature_id)
                { 
                    //check type of monster
                    v[j].drone[drone_id] = radar;
                    
                    // cerr << "fish id : " << creature_id << endl;
                    // cerr << "pos : " << radar << endl;
                    break ;
                }
            }
            // cerr << "radar : " << radar << endl;
            // cerr << "drone id : " << drone_id << endl;

        }
       
        int s = 0;
        
        sort(v.begin(), v.end(), compare);
        // j = -1;
        // while (++j < creature_count)
        // {
        //    cerr << "type : " << v[j].type << endl;
        // }
        int     tmp_x;
        int     tmp_y;
      
        // aya wahda nscanniha nb9a tab3ha 7ta n5rjha mn borders
        // if (scanned.size() == 11)
        //     cerr << "size : " << scanned.back() << endl;
        j = -1;
        while (++j < v.size())
        {
            if (v[j].scanned)
            {
                if (v[j].type == -1)
                {
                    cerr << "\t here \t\n";
                }
                v.erase(v.begin() + j);
            }
        }
        //  lamba[0] = 0;
        //  lamba[1] = 0;
        for (int i = 0; i < my_drone_count; i++) {

            // Write an action using cout. DON'T FORGET THE "<< endl"
            // // To debug: cerr << "Debug messages..." << endl;

            if (drone[i].emergency)
            {
                cout << "WAIT 0" << endl;
            }
            else
            {
               
                set_coords(i, ids[i], tmp_x, tmp_y, coords);
                if (v.empty())
                {
                    cerr << "move to report" << endl;
                    cout << "MOVE " << 500 << " " << 0 << " 0" << endl;
                }
                else
                {
                    
                    if (drone[i].y - 600 >= 1500 && battery >= 5 && turn % 2 == 0)
                    {
                        cout << "MOVE " << drone[i].x << " " << drone[i].y << " 1" << endl; // MOVE <x> <y> <light (1|0)> | WAIT <light (1|0)>
                        // light[i] = 1;
                    }
                    else
                    {
                        // light[i] = 0;
                        cout << "MOVE " << drone[i].x << " " << drone[i].y << " 0" << endl; // MOVE <x> <y> <light (1|0)> | WAIT <light (1|0)>
                    }
                }
            }

        }
    }
}
